# 搜索引擎项目设计

线程安全版的单例模式设计

```c++
//设计1 内部类+c++11新特性
.h文件
class Cppjieba
:public SplitTool
{
public:
    static SplitTool*getSplitTool();
    virtual vector<string> cut(const string &sentence) override;
private:
    Cppjieba();
    virtual ~Cppjieba() {}
    class AutoRelease
    {
    public:
        ~AutoRelease()
        {
            if(_splittool)
            {
                delete _splittool;
                _splittool = nullptr;
            }
        }
    };
private:
    unordered_map<string,string> &_configs;//配置文件
    cppjieba::Jieba _jieba;
    static SplitTool *_splittool;
    static AutoRelease _ar;//内部类+静态栈上成员函数==单例模式自动释放
    static std::once_flag _initflag;
};

.cc
SplitTool* Cppjieba::getSplitTool()
{
    //采用c++11的新特性
    //std::call_once 保证了 Cppjieba 实例的创建是线程安全的，
    //并且只会在第一次调用时执行。
    //这避免了多线程环境下可能出现的竞态条件问题
    std::call_once(_initflag,[](){
        _splittool = new Cppjieba();
    });
    return _splittool;
}

//设计2  智能指针+c++11新特性
.h文件
class Configuration
{
public:
    static Configuration*getInstance();
    unordered_map<string,string> & getConfigMap();
    ~Configuration() {}
private:
    Configuration(){}

private:
    static unique_ptr<Configuration> _pConfig;
    static once_flag _initflag;
    unordered_map<string,string> _configs;
    unordered_set<string> _stopWords;
};
.cc文件
Configuration * Configuration::getInstance()
{
    call_once(_initflag,[](){
              _pConfig.reset(new Configuration());
     });
    return _pConfig.get();
}
```



